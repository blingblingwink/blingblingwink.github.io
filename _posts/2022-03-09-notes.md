---
layout:     post
title:      "并发控制协议概述"
subtitle:   "Summary of concurrency control"
date:       2022-03-09 22:24:00
author:     "Ethan"
header-img: "img/notes.jpg"
catalog: false
tags:
    - 学习
    - 数据库
---


# 2PL
2PL即two phase locking，包含两个阶段，分别是扩张和收缩阶段，扩张阶段只能加锁，收缩阶段只能释放锁，注意**2PL不能避免死锁**，比如有两个事务T1，T2，T1已经持有了X的写锁，T2已经持有了Y的写锁，此时，T1想申请Y的读锁，T2想申请X的读锁，但两者都无法申请成功，因此形成死锁。可以说，就是两方都不肯让步，导致两方都无法继续往下进行，感情中亦如是，总得有个先让步的^_^

为了解决2PL的死锁问题，人们提出了2PL以下3个版本，除了no wait之外，wait die和wound wait的实现都是基于事务开始时间戳这一概念，用TS(Ti)表示，数值越小表示事务Ti开始地越早。同时，他们又分为剥夺式和非剥夺式，剥夺式表示在遇到锁冲突时，会回滚正在持有锁的事务。
## no wait
非剥夺式。no wait即没有等待，事务申请锁发生冲突时不等待锁释放，直接回滚。这种2PL实现简单，但吞吐量不高，因为有些锁冲突其实不会造成死锁。
## wait die
非剥夺式。wait die这组词看着迷糊，其实对应着两种事务，分别是老事务和新事务，意思是发生锁冲突时，老事务选择等待锁释放（即wait），新事务直接回滚（即die）。新老事务是相对当前持有锁的事务而言的，如果当前持有锁的事务为Ti，时间戳为TS(Ti)，另一个事务为Tj，时间戳为TS(Tj)，如果TS(Ti)<TS(Tj)，则称Tj为新事务，反之则称Tj为老事务。
## wound wait
剥夺式。同上，wound对应老事务，意思是老事务和当前持有锁的事务发生锁冲突时，当前持有锁的事务直接回滚，释放锁，老事务获得锁，也就是老事务伤害了当前持有锁的事务。wait对应新事务，意思是新事务和当前持有锁的事务发生锁冲突时，新事务选择等待锁释放。
# MVCC
