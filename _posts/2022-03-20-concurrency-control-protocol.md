---
layout:     post
title:      "并发控制协议概述"
subtitle:   "Summary of concurrency control protocol"
date:       2022-03-20 21:55:00
author:     "Ethan"
catalog: false
header-style: text
tags:
    - 数据库
---
>System is Art of Compromise

并发控制协议有很多，不同的协议适合不同的工作负载，比如基于锁的，也就是悲观并发控制协议适合冲突率高的负载（update intensive），而乐观并发控制协议适合冲突率低的负载（read intensive）。  
人们一直渴望提出更完美的协议，在保证正确性（ACID）的情况下，尽量提高吞吐量（高并发），各种协议各有所长，下面简单介绍几种基本的并发控制协议。
# 两阶段封锁协议 2PL
2PL即two phase locking，包含两个阶段，分别是扩张和收缩阶段，扩张阶段只能加锁，收缩阶段只能释放锁，注意**2PL不能避免死锁**，比如有两个事务T1，T2，T1持有了X的写锁，T2持有了Y的写锁，此时，T1想申请Y的读锁，T2想申请X的读锁，但两者都无法申请成功，因此形成死锁。

2PL从释放锁的时机分为两类：   
**Strict 2PL：** 事务持有的**互斥锁**必须在提交后再释放  
**Rigorous 2PL：** 事务持有的**所有锁**必须再提交后再释放
> Grammar notes: rigorous比strict更严格^_^

为了解决2PL的死锁问题，人们提出了2PL以下4个版本，这也是2PL的另一种分类，其中wait die和wound wait的实现是基于时间戳这一概念。同时，他们又分为剥夺式和非剥夺式，剥夺式表示在遇到锁冲突时，有可能会回滚正在持有锁的事务。

**DL_DETECT**  
剥夺式。DL_DETECT即deadlock detection，死锁检测，这种算法会构造事务之间的有向等待图（waits-for graph），定期检查图中是否出现了环，如果有环说明出现了死锁，这时需要选择一个事务回滚，通常会根据事务已经执行的时长、持有的资源数量等因素综合考虑被回滚的事务。  
多线程并发地去更新等待图是需要加锁的，因此这会成为性能瓶颈，有个优化的方法是每个线程只维护线程本地涉及的锁等待关系，再由单独的环检测线程去扫描其他每个线程的局部图，进而构造出全局图，最后来判断是否存在环。

**NO_WAIT**  
非剥夺式。no wait即没有等待，事务申请锁发生冲突时不等待锁释放，直接回滚。这种2PL实现简单，但回滚率很高。

**WAIT_DIE**  
非剥夺式。wait die这组词看着迷糊，其实对应着两种事务，分别是老事务和新事务，意思是发生锁冲突时，老事务选择等待锁释放（即wait），新事务直接回滚（即die）。新老事务是相对当前持有锁的事务而言的，如果当前持有锁的事务为Ti，时间戳为TS(Ti)，另一个事务为Tj，时间戳为TS(Tj)，如果TS(Ti)< TS(Tj)，则称Tj为新事务，反之则称Tj为老事务。

**WOUND_WAIT**  
剥夺式。同上，wound对应老事务，意思是老事务和当前持有锁的事务发生锁冲突时，当前持有锁的事务直接回滚，释放锁，老事务获得锁，也就是老事务伤害了当前持有锁的事务。wait对应新事务，意思是新事务和当前持有锁的事务发生锁冲突时，新事务选择等待锁释放。
# 时间戳排序协议 T/O
**Basic T/O**  
每个数据库对象X（一般是记录），会额外维护两个字段，分别是W-TS(X)和R-TS(X)，W-TS(X)的值是上一个成功写X的事务的时间戳，R-TS(X)的值是上一个成功读X的事务的时间戳。  
- 对于事务Ti的读操作，如果TS(Ti)< W-TS(X)，这就意味着Ti想要读取一个对于它来说，是存在于未来的版本的数据，这时要回滚并重新启动Ti，重新启动会获得一个新的时间戳；如果TS(Ti)> W-TS(X)，那么Ti可以读取X，并且更新R-TS(X)=max(R-TS(X),TS(Ti))。
- 对于事务Ti的写操作，如果TS(Ti)< R-TS(X)或者TS(Ti)< W-TS(X)，那么要回滚并重新启动Ti，否则允许Ti更新X的值并更新W-TS(X)=TS(Ti)。注：TS(Ti)< R-TS(X)不被允许是因为X已经被更新（newer）的事务读取过，TS(Ti)< W-TS(X)不被允许是因为X已经被更新（newer）的事务写了。
- 不论是读还是写，事务Ti都会拷贝X到自己私有的内存区，这是为了实现RR（可重复读）。

Basic T/O的缺点在于  
- 内存拷贝的开销
- 分配时间戳（多个线程想要申请时间戳，但一次只能给一个）
- 长事务可能存在饥饿现象（长事务可能总是会访问被新事务访问过的数据项）

**Partition based T/O**  
将数据库的数据分为多个不相交的子集，称之为水平分区（horizontal partition），也叫分片（shard），每个分区有一个锁。每个事务在到达DBMS时会被分配一个时间戳，每个事务要知道自己的读写集，并尝试申请自己会访问到的所有分区的锁，分区锁会分配给等待队列中时间戳最小的事务，其他事务则等待，只有在获取了**所有**分区的锁后，事务才会开始执行。  
该策略适合大多数（最好是全部）事务都只访问一个分区的负载情况。

# 乐观并发控制协议 OCC
每个事务都有私有的内存区，用于保存读取或修改的数据项。共分为3个阶段，如下：  
**Read phase：** 记录事务的读写集，并将读取或修改的数据项保存在事务私有的内存区中。  
**Validation phase：** 检验是否和其他活跃事务产生了冲突，事务进入这个阶段会被赋予一个时间戳。要满足以下3个条件之一才能通Validation phase：
- Ti在Tj开始前就完成了
- Ti的写集和Tj的读集没有交叉，并且在Tj开始write phase之前Ti就完成了write phase。这意味着Ti的write phase和Tj的read phase可以处于同一时间，但Ti的写不会影响Tj的读，并且Ti的写也不会影响Tj的写。
- Ti的写集和Tj的读写集都没有交叉，并且在Tj完成read phase之前Ti就已经完成了read phase。这意味着Ti的写不会影响Tj的读和写，并且Tj的写不会影响Ti的读。  

**Write phase：** 如果validation phase通过了则将事务私有的内存区中暂存的写操作写到数据库中，否则回滚并重启事务。  
OCC的缺点在于：
- 内存拷贝开销大
- 事务回滚开销大（因为事务都是完成了所有的读写操作再进入validation phase检查是否能提交）

# 多版本并发控制协议 MVCC
DBMS会维护记录的多个版本，写操作会创建一个新的版本，读操作会读事务开始时最新的版本（事务开始后有新的版本是读不到的）。MVCC中读写操作互不阻塞，但写操作会阻塞写操作。MVCC在大量数据库中得到了使用包括PostgreSQL和MySQL。  
MVCC其实不能完全算是并发控制协议，它的概念更广一点，包括如下几个方面：  
**并发控制协议：** MVCC要结合其他并发控制协议才能发挥构成一个完整的并发控制协议，包括Timestamp Ordering，OCC和2PL。  
**版本管理：** 即如何存储和管理版本链，MVCC中的某条记录的多个版本构成一个链表，记录中有一个字段是指针，用于链接这些版本。  
**垃圾回收：** MVCC因为引入了多版本，意味着它要实现垃圾回收的功能，可回收的版本包括
- 过旧的版本：当前所有活跃的事务已经不再需要这个版本了
- 失效的版本：事务回滚导致版本失效

**索引管理：** 主键索引指向版本链的头部。

# References
- https://zhuanlan.zhihu.com/p/138284838
- https://15445.courses.cs.cmu.edu/fall2018/slides/18-timestampordering.pdf
- https://people.eecs.berkeley.edu/~fox/summaries/database/optimistic_concurrency.html
- https://15445.courses.cs.cmu.edu/fall2018/slides/19-multiversioning.pdf